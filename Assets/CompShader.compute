// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel validate
#pragma kernel record
#pragma kernel run

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct Node {
	float3 pos;
	float force;
};

struct Particle {
	float3 position;
	float3 velocity;
};

struct ErrorData {
	float3 recordedPosition;
	float error;
};

StructuredBuffer<Particle> _ParticleDataIn;
RWStructuredBuffer<Particle> _ParticleDataOut;
RWStructuredBuffer<ErrorData> _ErrorData;

StructuredBuffer<Node> _Nodes;

#define thread_group_size_x 1
#define thread_group_size_y 1


static float3 g = float3(-0.0000918, 0.0, 0.0);

float deltaTime;
int _particleCount;
int _maxIterations;
int _dimensionWidth;


[numthreads(thread_group_size_x, thread_group_size_y, 1)]
void validate(uint3 id : SV_DispatchThreadID)
{
	//int idx = id.x + id.y * 512; //thread_group_size_x * 32;
	const unsigned int idx = id.x + _dimensionWidth * id.y; //(id.y + 1 * id.z);

	float3 position = _ParticleDataIn[idx].position;
	float3 velocity = _ParticleDataIn[idx].velocity;

	for (int iter = 0; iter < _maxIterations; iter++) {

		const unsigned int recordingIndex = idx + iter * _particleCount;
		float3 recordedPosition = _ErrorData[recordingIndex].recordedPosition;

		float3 sum_vel = float3(0, 0, 0);
		for (int i = 0; i < 3; i++) {
			float3 node_pos = _Nodes[i].pos;
			float distanceToNode = max(2.0, distance(node_pos, position));
			float3 deltaVelocity = normalize(node_pos - position) * _Nodes[i].force / pow(distanceToNode, 1.7);
			sum_vel = sum_vel + deltaVelocity;
		}

		velocity += (sum_vel / 6.0) * 0.5;
		velocity += g;
		float damping = 0.995;
		velocity = velocity * damping;

		position += velocity;
		float errorDistance = distance(position, recordedPosition);
		_ErrorData[recordingIndex].error = errorDistance;//pow(abs(_Positions[idx] - recordedPosition), 1.0); //pow(distance(_Positions[idx], recordedPosition), 20.0);
	}
}

[numthreads(thread_group_size_x, thread_group_size_y, 1)]
void record(uint3 id : SV_DispatchThreadID)
{
	//int idx = id.x + id.y * 512; //thread_group_size_x * 32;
	const unsigned int idx = id.x + _dimensionWidth * id.y; //(id.y + 1 * id.z);

	float3 position = _ParticleDataIn[idx].position;
	float3 velocity = _ParticleDataIn[idx].velocity;

	for (int iter = 0; iter < _maxIterations; iter++) {
		float3 sum_vel = float3(0, 0, 0);
		for (int i = 0; i < 3; i++) {
			float3 node_pos = _Nodes[i].pos;
			float distanceToNode = max(2.0, distance(node_pos, position));
			float3 deltaVelocity = normalize(node_pos - position) * _Nodes[i].force / pow(distanceToNode, 1.7);
			sum_vel = sum_vel + deltaVelocity;
		}

		velocity += (sum_vel / 6.0) * 0.5;
		velocity += g;
		float damping = 0.995;
		velocity = velocity * damping;

		position = position + velocity;
		_ErrorData[idx + iter * _particleCount].recordedPosition = position;
	}
}

[numthreads(thread_group_size_x, thread_group_size_y, 1)]
void run(uint3 id : SV_DispatchThreadID)
{
	//int idx = id.x + id.y * 512; //thread_group_size_x * 32;
	const unsigned int idx = id.x + _dimensionWidth * id.y; //(id.y + 1 * id.z);

	float3 position = _ParticleDataOut[idx].position;
	float3 velocity = _ParticleDataOut[idx].velocity;

	float3 sum_vel = float3(0, 0, 0);
	for (int i = 0; i < 3; i++) {
		float3 node_pos = _Nodes[i].pos;
		float distanceToNode = max(2.0, distance(node_pos, position));
		float3 deltaVelocity = normalize(node_pos - position) * _Nodes[i].force / pow(distanceToNode, 1.7);
		sum_vel = sum_vel + deltaVelocity;
	}

	velocity += (sum_vel / 6.0) * 0.5;
	velocity += g;
	float damping = 0.995;
	velocity = velocity * damping;

	position += velocity;
	_ParticleDataOut[idx].position = position;
	_ParticleDataOut[idx].velocity = velocity;
	
}

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel validate
#pragma kernel record
#pragma kernel run

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct Node {
	float3 pos;
	float force;
};

struct Particle {
	float3 position;
	float3 velocity;
};

StructuredBuffer<Particle> _ParticleDataIn;
RWStructuredBuffer<Particle> _ParticleDataOut;

RWStructuredBuffer<float> _ErrorData;
RWStructuredBuffer<float3> _RecordedData;

StructuredBuffer<Node> _Nodes;

#define thread_group_size_x 1
#define thread_group_size_y 1


static float3 g = float3(-0.0000918, 0.0, 0.0);

float deltaTime;
int _particleCount;
unsigned int _maxIterations;
unsigned int _dimensionWidth; 


[numthreads(thread_group_size_x, thread_group_size_y, 1)]
void validate(uint3 id : SV_DispatchThreadID)
{
	//int idx = id.x + id.y * 512; //thread_group_size_x * 32;
	const unsigned int idx = id.x + _dimensionWidth * id.y; //(id.y + 1 * id.z);

	float3 position = _ParticleDataIn[idx].position;
	float3 velocity = _ParticleDataIn[idx].velocity;

	float errorAccumulated = 0.0;

	for (unsigned int iter = 0; iter < _maxIterations; iter++) {
		const unsigned int recordingIndex = idx + iter * _particleCount /*/ 10*/;
		float3 recordedPosition;
		//bool compare = iter % 10 == 0;
		//if (compare) {
			recordedPosition = _RecordedData[recordingIndex];
		//}

		float3 sum_vel = float3(0, 0, 0);
		for (int i = 0; i < 3; i++) {
			float3 node_pos = _Nodes[i].pos;
			float distanceToNode = max(2.0, distance(node_pos, position));
			float3 deltaVelocity = normalize(node_pos - position) * _Nodes[i].force / pow(distanceToNode, 1.7);
			sum_vel = sum_vel + deltaVelocity;
		}

		velocity += (sum_vel / 6.0) * 0.5;
		velocity += g;
		float damping = 0.995;
		velocity = velocity * damping;

		position += velocity;
		//if (compare) {
			float errorDistance = distance(position, recordedPosition);//pow(abs(_Positions[idx] - recordedPosition), 1.0); //pow(distance(_Positions[idx], recordedPosition), 20.0);
			errorAccumulated += errorDistance;
		//}
	}
	_ErrorData[idx] = errorAccumulated;
}

[numthreads(thread_group_size_x, thread_group_size_y, 1)]
void record(uint3 id : SV_DispatchThreadID)
{
	//int idx = id.x + id.y * 512; //thread_group_size_x * 32;
	const unsigned int idx = id.x + _dimensionWidth * id.y; //(id.y + 1 * id.z);

	float3 position = _ParticleDataIn[idx].position;
	float3 velocity = _ParticleDataIn[idx].velocity;

	for (unsigned int iter = 0; iter < _maxIterations; iter++) {
		float3 sum_vel = float3(0, 0, 0);
		for (int i = 0; i < 3; i++) {
			float3 node_pos = _Nodes[i].pos;
			float distanceToNode = max(2.0, distance(node_pos, position));
			float3 deltaVelocity = normalize(node_pos - position) * _Nodes[i].force / pow(distanceToNode, 1.7);
			sum_vel = sum_vel + deltaVelocity;
		}

		velocity += (sum_vel / 6.0) * 0.5;
		velocity += g;
		float damping = 0.995;
		velocity = velocity * damping;

		position = position + velocity;

		//if (iter % 10 == 0) {
			_RecordedData[idx + iter * _particleCount /*/ 10*/] = position;
		//}
	}
}

[numthreads(thread_group_size_x, thread_group_size_y, 1)]
void run(uint3 id : SV_DispatchThreadID)
{
	//int idx = id.x + id.y * 512; //thread_group_size_x * 32;
	const unsigned int idx = id.x + _dimensionWidth * id.y; //(id.y + 1 * id.z);

	float3 position = _ParticleDataIn[idx].position;
	float3 velocity = _ParticleDataIn[idx].velocity;

	float3 sum_vel = float3(0, 0, 0);
	for (unsigned int i = 0; i < 3; i++) {
		float3 node_pos = _Nodes[i].pos;
		float distanceToNode = max(2.0, distance(node_pos, position));
		float3 deltaVelocity = normalize(node_pos - position) * _Nodes[i].force / pow(distanceToNode, 1.7);
		sum_vel = sum_vel + deltaVelocity;
	}

	velocity += (sum_vel / 6.0) * 0.5;
	velocity += g;
	float damping = 0.995;
	velocity = velocity * damping;

	position += velocity;
	_ParticleDataOut[idx].position = position;
	_ParticleDataOut[idx].velocity = velocity;
	
}

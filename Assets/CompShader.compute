// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel record


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct Node {
	float3 pos;
	float force;
};

struct Particle {
	float3 position;
	float3 velocity;
};

struct ErrorData {
	float3 recordedPosition;
	float error;
};

StructuredBuffer<Particle> _ParticleData;
RWStructuredBuffer<ErrorData> _ErrorData;

RWStructuredBuffer<Node> _Nodes;

#define thread_group_size_x 1
#define thread_group_size_y 1


static float3 g = float3(-0.0000918, 0.0, 0.0);

float deltaTime;
int _particleCount;
int _maxIterations;

[numthreads(thread_group_size_x, thread_group_size_y, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	//int idx = id.x + id.y * 512; //thread_group_size_x * 32;
	const unsigned int idx = id.x + 256 * id.y; //(id.y + 1 * id.z);

	float3 position = _ParticleData[idx].position;
	float3 velocity = _ParticleData[idx].velocity;

	for (int iter = 0; iter < _maxIterations; iter++) {

		const unsigned int recordingIndex = idx + iter * _particleCount;
		float3 recordedPosition = _ErrorData[recordingIndex].recordedPosition;

		float3 sum_vel = float3(0, 0, 0);
		for (int i = 0; i < 3; i++) {
			float3 node_pos = _Nodes[i].pos;
			float distanceToNode = max(2.0, distance(node_pos, position));
			float3 deltaVelocity = normalize(node_pos - position) * _Nodes[i].force / pow(distanceToNode, 1.7);
			sum_vel = sum_vel + deltaVelocity;
		}

		velocity += (sum_vel / 6.0) * 0.5;
		velocity += g;
		float damping = 0.995;
		velocity = velocity * damping;

		position += velocity;
		//_ParticleData[idx].position = position;
		//_ParticleData[idx].velocity = velocity;

		float errorDistance = distance(position, recordedPosition);

		_ErrorData[recordingIndex].error = errorDistance;//pow(abs(_Positions[idx] - recordedPosition), 1.0); //pow(distance(_Positions[idx], recordedPosition), 20.0);
	}
}


[numthreads(thread_group_size_x, thread_group_size_y, 1)]
void record(uint3 id : SV_DispatchThreadID)
{
	//int idx = id.x + id.y * 512; //thread_group_size_x * 32;
	const unsigned int idx = id.x + 256 * id.y; //(id.y + 1 * id.z);

	float3 position = _ParticleData[idx].position;
	float3 velocity = _ParticleData[idx].velocity;

	for (int iter = 0; iter < _maxIterations; iter++) {
		float3 sum_vel = float3(0, 0, 0);
		for (int i = 0; i < 3; i++) {
			float3 node_pos = _Nodes[i].pos;
			float distanceToNode = max(2.0, distance(node_pos, position));
			float3 deltaVelocity = normalize(node_pos - position) * _Nodes[i].force / pow(distanceToNode, 1.7);
			sum_vel = sum_vel + deltaVelocity;
		}

		velocity += (sum_vel / 6.0) * 0.5;
		velocity += g;
		float damping = 0.995;
		velocity = velocity * damping;

		position = position + velocity;

		//_ParticleData[idx].position = position + velocity;
		//_ParticleData[idx].velocity = velocity;

		_ErrorData[idx + iter * _particleCount].recordedPosition = position;
	}
}

